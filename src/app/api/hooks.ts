/**
 * hooks.ts
 * Hooks for managing api request and responses.
 */

// Node Modules
import {useCallback} from 'react';
import {useDispatch} from 'react-redux';

// Actions
import api from 'app/api/actions';
import {pushAppException} from 'app/common/actions';
import {postAuthRefresh} from 'app/auth/actions';

// Constant
// const EXCEPTION_NOTIFICATION_TIMEOUT = 5000;

// Hooks
import {useAuthLogoutAPI} from 'app/auth/hooks';

// Utils
import {createActionKey} from './utils';

export function useAPIResponse(key: string) {
  // Hooks
  const dispatch = useDispatch();
  const {post: postAuthLogout} = useAuthLogoutAPI();

  // TODO: Add in try / catch / exception.
  const handleResponse = useCallback(
    async (action, onSuccess, onError = (data) => data) => {

      const handleError = (data) => {
        // Utilizes optional callback to create custom error object, otherwise
        // returns data argument.
        const error = onError(data);

        // Dispatches api error action for specified api key.
        dispatch(api[`set${createActionKey(key)}Error`](error));
      };

      let data = null;
      const response = await dispatch(action());

      if (response instanceof Response) {
        // Ensures that response is of correct instance otherwise handles as an
        // exception.
        if ([200, 201, 400].includes(response.status)) {
          // Parses JSON object if response is not automatically generated by
          // server.
          data = await response.json();
          if ([200, 201].includes(response.status)) {
            onSuccess(data);
          } else if (response.status === 400) {
            handleError(data);
          }
        } else if (response.status === 401) {
          // TODO: Find solution to issue where refresh route is called for all
          // methods when first rendered. Issue occurs when access_token needs
          // to be refreshed on page load.
          const authRefreshResponse = await dispatch(postAuthRefresh());

          if (authRefreshResponse.status === 200) {

            const authRefreshData = await authRefreshResponse.json();
            const accessToken = authRefreshData.access_token;

            if (accessToken) {
              // Checks that access token exists in response.
              localStorage.setItem('access_token', accessToken);

              // Calls and returns action again now with updated access_token.
              return handleResponse(action, onSuccess, onError);
            } else {
              // Exists for case when response status is 200 and error in data.
              // Removes local storage value to force to go back to login screen.
              postAuthLogout();
            }
          } else {
            postAuthLogout();
          }

          dispatch(api.setAuthRefreshIsLoading(false));
        } else {
          if (response.status === 403) {
            handleError({ message: 'Forbidden' });
          } else if (response.status === 422) {
            // Should not occur as `Authorization` header should not be included
            // if token is `undefined`.
            handleError({ message: 'Unprocessable entity'});
          } else if (response.status === 500) {
            handleError({ message: 'Server Error' });
          }
        }

        // Sets the status code of the response to api redux store.
        dispatch(api[`set${createActionKey(key)}StatusCode`](response.status));
      } else {

        // Sets the exception message to api redux store.
        dispatch(api[`set${createActionKey(key)}Exception`](response));

        // Creates an exception notification to render in app.
        dispatch(pushAppException(response, null));
      }

      // Sets the loading state of the api to `false`
      dispatch(api[`set${createActionKey(key)}IsLoading`](false));

      // Returns object with response data and status.
      return {
        data,
        status: response.status,
      };
  }, [dispatch, postAuthLogout]);

  return handleResponse;
}
